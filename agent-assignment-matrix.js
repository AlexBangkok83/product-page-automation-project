/**
 * AGENT ASSIGNMENT MATRIX
 * 
 * This module provides intelligent agent assignment based on task analysis,
 * workload balancing, skill matching, and real-time availability. It ensures
 * optimal agent selection for maximum efficiency and quality outcomes.
 */

const EventEmitter = require('events');

class AgentAssignmentMatrix extends EventEmitter {
  constructor(agentSystem) {
    super();
    this.agentSystem = agentSystem;
    this.assignmentRules = new Map();
    this.skillMatrix = new Map();
    this.workloadBalancer = new Map();
    this.assignmentHistory = [];
    this.performanceMetrics = new Map();
    this.exclusivityRules = new Map();
    this.prerequisiteChains = new Map();
    
    this.setupAssignmentMatrix();
    this.initializeSkillMapping();
    this.configureWorkloadBalancing();
    this.startPerformanceTracking();
    
    console.log('🎯 Agent Assignment Matrix initialized');
  }
  
  setupAssignmentMatrix() {
    console.log('📋 Setting up comprehensive assignment matrix...');
    
    // Define sophisticated assignment rules for different task categories
    this.assignmentRules = new Map([\n      // DEVELOPMENT TASKS\n      ['frontend-development', {\n        primaryAgents: ['frontend-developer'],\n        supportAgents: ['ui-designer', 'whimsy-injector'],\n        requiredSkills: ['javascript', 'react', 'css', 'html'],\n        optionalSkills: ['typescript', 'webpack', 'testing'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '2-4 hours' },\n          medium: { agents: 2, timeEstimate: '1-2 days' },\n          complex: { agents: 3, timeEstimate: '3-5 days' }\n        },\n        dependencies: ['ui-designer'],\n        handoffTo: ['test-writer-fixer'],\n        qualityGates: ['code-review', 'testing', 'accessibility-check']\n      }],\n      \n      ['backend-development', {\n        primaryAgents: ['backend-architect'],\n        supportAgents: ['api-tester', 'infrastructure-maintainer'],\n        requiredSkills: ['nodejs', 'databases', 'api-design'],\n        optionalSkills: ['microservices', 'caching', 'security'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '3-6 hours' },\n          medium: { agents: 2, timeEstimate: '1-3 days' },\n          complex: { agents: 3, timeEstimate: '4-7 days' }\n        },\n        dependencies: [],\n        handoffTo: ['api-tester', 'devops-automator'],\n        qualityGates: ['unit-tests', 'integration-tests', 'security-scan']\n      }],\n      \n      ['fullstack-feature', {\n        primaryAgents: ['frontend-developer', 'backend-architect'],\n        supportAgents: ['ui-designer', 'api-tester', 'devops-automator'],\n        requiredSkills: ['fullstack', 'system-design'],\n        optionalSkills: ['performance-optimization', 'security'],\n        complexity: {\n          simple: { agents: 2, timeEstimate: '1-2 days' },\n          medium: { agents: 4, timeEstimate: '3-5 days' },\n          complex: { agents: 6, timeEstimate: '1-2 weeks' }\n        },\n        coordination: 'parallel-with-sync-points',\n        dependencies: ['ui-designer'],\n        handoffTo: ['test-writer-fixer', 'performance-benchmarker'],\n        qualityGates: ['design-review', 'api-documentation', 'e2e-tests']\n      }],\n      \n      // DESIGN TASKS\n      ['ui-design', {\n        primaryAgents: ['ui-designer'],\n        supportAgents: ['brand-guardian', 'ux-researcher'],\n        requiredSkills: ['figma', 'design-systems', 'user-interface'],\n        optionalSkills: ['prototyping', 'animation', 'accessibility'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '2-4 hours' },\n          medium: { agents: 2, timeEstimate: '1-2 days' },\n          complex: { agents: 3, timeEstimate: '3-4 days' }\n        },\n        dependencies: ['ux-researcher'],\n        handoffTo: ['frontend-developer'],\n        qualityGates: ['brand-consistency', 'accessibility-compliance', 'stakeholder-approval']\n      }],\n      \n      ['ux-research', {\n        primaryAgents: ['ux-researcher'],\n        supportAgents: ['analytics-reporter', 'feedback-synthesizer'],\n        requiredSkills: ['user-research', 'data-analysis', 'personas'],\n        optionalSkills: ['a-b-testing', 'surveys', 'interviews'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '1-2 days' },\n          medium: { agents: 2, timeEstimate: '3-5 days' },\n          complex: { agents: 3, timeEstimate: '1-2 weeks' }\n        },\n        dependencies: [],\n        handoffTo: ['ui-designer', 'sprint-prioritizer'],\n        qualityGates: ['sample-size-validation', 'statistical-significance', 'actionable-insights']\n      }],\n      \n      ['brand-design', {\n        primaryAgents: ['brand-guardian'],\n        supportAgents: ['visual-storyteller', 'content-creator'],\n        requiredSkills: ['brand-design', 'visual-identity', 'guidelines'],\n        optionalSkills: ['illustration', 'photography', 'video'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '1-2 days' },\n          medium: { agents: 2, timeEstimate: '3-5 days' },\n          complex: { agents: 3, timeEstimate: '1-2 weeks' }\n        },\n        dependencies: [],\n        handoffTo: ['ui-designer', 'content-creator'],\n        qualityGates: ['brand-guidelines-compliance', 'stakeholder-approval', 'consistency-check']\n      }],\n      \n      // TESTING AND QA\n      ['automated-testing', {\n        primaryAgents: ['test-writer-fixer'],\n        supportAgents: ['api-tester', 'performance-benchmarker'],\n        requiredSkills: ['test-automation', 'testing-frameworks', 'ci-cd'],\n        optionalSkills: ['load-testing', 'security-testing', 'mobile-testing'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '4-8 hours' },\n          medium: { agents: 2, timeEstimate: '1-3 days' },\n          complex: { agents: 3, timeEstimate: '4-6 days' }\n        },\n        dependencies: ['frontend-developer', 'backend-architect'],\n        handoffTo: ['devops-automator'],\n        qualityGates: ['test-coverage', 'test-reliability', 'execution-speed']\n      }],\n      \n      ['api-testing', {\n        primaryAgents: ['api-tester'],\n        supportAgents: ['backend-architect', 'performance-benchmarker'],\n        requiredSkills: ['api-testing', 'postman', 'rest-graphql'],\n        optionalSkills: ['load-testing', 'security-testing', 'documentation'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '2-4 hours' },\n          medium: { agents: 2, timeEstimate: '1-2 days' },\n          complex: { agents: 3, timeEstimate: '3-5 days' }\n        },\n        dependencies: ['backend-architect'],\n        handoffTo: ['performance-benchmarker'],\n        qualityGates: ['endpoint-coverage', 'error-handling', 'performance-baseline']\n      }],\n      \n      ['performance-testing', {\n        primaryAgents: ['performance-benchmarker'],\n        supportAgents: ['infrastructure-maintainer', 'workflow-optimizer'],\n        requiredSkills: ['performance-testing', 'load-testing', 'monitoring'],\n        optionalSkills: ['database-optimization', 'caching', 'cdn'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '3-6 hours' },\n          medium: { agents: 2, timeEstimate: '1-2 days' },\n          complex: { agents: 3, timeEstimate: '3-4 days' }\n        },\n        dependencies: ['backend-architect', 'frontend-developer'],\n        handoffTo: ['infrastructure-maintainer'],\n        qualityGates: ['baseline-established', 'bottlenecks-identified', 'optimization-recommendations']\n      }],\n      \n      // DEPLOYMENT AND INFRASTRUCTURE\n      ['deployment-automation', {\n        primaryAgents: ['devops-automator'],\n        supportAgents: ['infrastructure-maintainer', 'backend-architect'],\n        requiredSkills: ['ci-cd', 'docker', 'cloud-platforms'],\n        optionalSkills: ['kubernetes', 'terraform', 'monitoring'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '2-4 hours' },\n          medium: { agents: 2, timeEstimate: '1-2 days' },\n          complex: { agents: 3, timeEstimate: '3-5 days' }\n        },\n        dependencies: ['backend-architect', 'test-writer-fixer'],\n        handoffTo: ['infrastructure-maintainer'],\n        qualityGates: ['deployment-success', 'rollback-capability', 'monitoring-setup']\n      }],\n      \n      ['infrastructure-setup', {\n        primaryAgents: ['infrastructure-maintainer'],\n        supportAgents: ['devops-automator', 'finance-tracker'],\n        requiredSkills: ['cloud-infrastructure', 'networking', 'security'],\n        optionalSkills: ['cost-optimization', 'disaster-recovery', 'compliance'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '4-8 hours' },\n          medium: { agents: 2, timeEstimate: '2-3 days' },\n          complex: { agents: 3, timeEstimate: '1-2 weeks' }\n        },\n        dependencies: [],\n        handoffTo: ['devops-automator', 'analytics-reporter'],\n        qualityGates: ['security-compliance', 'scalability-testing', 'cost-efficiency']\n      }],\n      \n      // PRODUCT AND STRATEGY\n      ['feature-planning', {\n        primaryAgents: ['sprint-prioritizer'],\n        supportAgents: ['trend-researcher', 'feedback-synthesizer'],\n        requiredSkills: ['product-management', 'roadmapping', 'stakeholder-management'],\n        optionalSkills: ['market-research', 'competitive-analysis', 'metrics'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '1-2 days' },\n          medium: { agents: 2, timeEstimate: '3-5 days' },\n          complex: { agents: 3, timeEstimate: '1-2 weeks' }\n        },\n        dependencies: ['trend-researcher', 'feedback-synthesizer'],\n        handoffTo: ['rapid-prototyper', 'ui-designer'],\n        qualityGates: ['stakeholder-alignment', 'resource-feasibility', 'success-metrics']\n      }],\n      \n      ['market-research', {\n        primaryAgents: ['trend-researcher'],\n        supportAgents: ['analytics-reporter', 'growth-hacker'],\n        requiredSkills: ['market-analysis', 'competitive-research', 'trend-identification'],\n        optionalSkills: ['surveys', 'focus-groups', 'data-mining'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '2-3 days' },\n          medium: { agents: 2, timeEstimate: '1 week' },\n          complex: { agents: 3, timeEstimate: '2-3 weeks' }\n        },\n        dependencies: [],\n        handoffTo: ['sprint-prioritizer', 'growth-hacker'],\n        qualityGates: ['data-reliability', 'actionable-insights', 'strategic-alignment']\n      }],\n      \n      ['rapid-prototyping', {\n        primaryAgents: ['rapid-prototyper'],\n        supportAgents: ['ui-designer', 'frontend-developer'],\n        requiredSkills: ['prototyping', 'mvp-development', 'user-testing'],\n        optionalSkills: ['no-code-tools', 'animation', 'user-feedback'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '1-2 days' },\n          medium: { agents: 2, timeEstimate: '3-5 days' },\n          complex: { agents: 3, timeEstimate: '1-2 weeks' }\n        },\n        dependencies: ['ui-designer'],\n        handoffTo: ['frontend-developer', 'ux-researcher'],\n        qualityGates: ['user-validation', 'technical-feasibility', 'iteration-ready']\n      }],\n      \n      // MARKETING AND GROWTH\n      ['growth-strategy', {\n        primaryAgents: ['growth-hacker'],\n        supportAgents: ['analytics-reporter', 'content-creator'],\n        requiredSkills: ['growth-hacking', 'metrics-analysis', 'experimentation'],\n        optionalSkills: ['viral-marketing', 'retention-strategies', 'conversion-optimization'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '1-2 days' },\n          medium: { agents: 2, timeEstimate: '3-5 days' },\n          complex: { agents: 3, timeEstimate: '1-2 weeks' }\n        },\n        dependencies: ['analytics-reporter'],\n        handoffTo: ['content-creator', 'twitter-engager'],\n        qualityGates: ['hypothesis-validation', 'experiment-design', 'success-metrics']\n      }],\n      \n      ['content-creation', {\n        primaryAgents: ['content-creator'],\n        supportAgents: ['brand-guardian', 'visual-storyteller'],\n        requiredSkills: ['copywriting', 'content-strategy', 'brand-voice'],\n        optionalSkills: ['seo', 'social-media', 'video-editing'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '1-2 days' },\n          medium: { agents: 2, timeEstimate: '3-4 days' },\n          complex: { agents: 3, timeEstimate: '1-2 weeks' }\n        },\n        dependencies: ['brand-guardian'],\n        handoffTo: ['instagram-curator', 'twitter-engager'],\n        qualityGates: ['brand-consistency', 'engagement-potential', 'seo-optimization']\n      }],\n      \n      ['social-media-campaign', {\n        primaryAgents: ['instagram-curator', 'twitter-engager', 'tiktok-strategist'],\n        supportAgents: ['content-creator', 'growth-hacker'],\n        requiredSkills: ['social-media-marketing', 'community-management', 'content-adaptation'],\n        optionalSkills: ['influencer-outreach', 'paid-advertising', 'analytics'],\n        complexity: {\n          simple: { agents: 2, timeEstimate: '3-5 days' },\n          medium: { agents: 3, timeEstimate: '1-2 weeks' },\n          complex: { agents: 4, timeEstimate: '2-4 weeks' }\n        },\n        coordination: 'platform-specific-parallel',\n        dependencies: ['content-creator'],\n        handoffTo: ['analytics-reporter'],\n        qualityGates: ['platform-optimization', 'engagement-rates', 'brand-safety']\n      }],\n      \n      // BUSINESS OPERATIONS\n      ['business-analysis', {\n        primaryAgents: ['analytics-reporter'],\n        supportAgents: ['finance-tracker', 'feedback-synthesizer'],\n        requiredSkills: ['data-analysis', 'business-intelligence', 'reporting'],\n        optionalSkills: ['predictive-analytics', 'data-visualization', 'kpi-tracking'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '1-2 days' },\n          medium: { agents: 2, timeEstimate: '3-5 days' },\n          complex: { agents: 3, timeEstimate: '1-2 weeks' }\n        },\n        dependencies: [],\n        handoffTo: ['sprint-prioritizer', 'finance-tracker'],\n        qualityGates: ['data-accuracy', 'actionable-insights', 'stakeholder-relevance']\n      }],\n      \n      ['legal-compliance', {\n        primaryAgents: ['legal-compliance-checker'],\n        supportAgents: ['finance-tracker', 'support-responder'],\n        requiredSkills: ['legal-compliance', 'privacy-regulations', 'terms-conditions'],\n        optionalSkills: ['international-law', 'intellectual-property', 'contracts'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '1-2 days' },\n          medium: { agents: 2, timeEstimate: '3-5 days' },\n          complex: { agents: 3, timeEstimate: '1-3 weeks' }\n        },\n        dependencies: [],\n        handoffTo: ['support-responder'],\n        qualityGates: ['compliance-verification', 'risk-assessment', 'documentation-completeness']\n      }],\n      \n      ['customer-support', {\n        primaryAgents: ['support-responder'],\n        supportAgents: ['feedback-synthesizer', 'legal-compliance-checker'],\n        requiredSkills: ['customer-service', 'communication', 'problem-solving'],\n        optionalSkills: ['technical-support', 'escalation-management', 'satisfaction-tracking'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '2-4 hours' },\n          medium: { agents: 2, timeEstimate: '1-2 days' },\n          complex: { agents: 3, timeEstimate: '3-5 days' }\n        },\n        dependencies: [],\n        handoffTo: ['feedback-synthesizer'],\n        qualityGates: ['customer-satisfaction', 'resolution-time', 'knowledge-base-update']\n      }],\n      \n      // SPECIALIZED TASKS\n      ['security-audit', {\n        primaryAgents: ['legal-compliance-checker', 'backend-architect'],\n        supportAgents: ['api-tester', 'infrastructure-maintainer'],\n        requiredSkills: ['security-auditing', 'penetration-testing', 'vulnerability-assessment'],\n        optionalSkills: ['compliance-frameworks', 'incident-response', 'security-training'],\n        complexity: {\n          simple: { agents: 2, timeEstimate: '2-3 days' },\n          medium: { agents: 3, timeEstimate: '1 week' },\n          complex: { agents: 4, timeEstimate: '2-3 weeks' }\n        },\n        dependencies: ['backend-architect'],\n        handoffTo: ['infrastructure-maintainer'],\n        qualityGates: ['vulnerability-assessment', 'penetration-testing', 'compliance-verification']\n      }],\n      \n      ['workflow-optimization', {\n        primaryAgents: ['workflow-optimizer'],\n        supportAgents: ['analytics-reporter', 'tool-evaluator'],\n        requiredSkills: ['process-optimization', 'workflow-analysis', 'automation'],\n        optionalSkills: ['change-management', 'training', 'roi-analysis'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '1-2 days' },\n          medium: { agents: 2, timeEstimate: '3-5 days' },\n          complex: { agents: 3, timeEstimate: '1-2 weeks' }\n        },\n        dependencies: ['analytics-reporter'],\n        handoffTo: ['tool-evaluator'],\n        qualityGates: ['efficiency-improvement', 'user-adoption', 'roi-validation']\n      }],\n      \n      ['tool-evaluation', {\n        primaryAgents: ['tool-evaluator'],\n        supportAgents: ['workflow-optimizer', 'finance-tracker'],\n        requiredSkills: ['tool-assessment', 'vendor-evaluation', 'integration-analysis'],\n        optionalSkills: ['cost-benefit-analysis', 'security-assessment', 'training-requirements'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '1-2 days' },\n          medium: { agents: 2, timeEstimate: '3-5 days' },\n          complex: { agents: 3, timeEstimate: '1-2 weeks' }\n        },\n        dependencies: [],\n        handoffTo: ['workflow-optimizer', 'finance-tracker'],\n        qualityGates: ['feature-comparison', 'cost-analysis', 'integration-feasibility']\n      }]\n    ]);\n    \n    console.log(`✅ Configured ${this.assignmentRules.size} comprehensive task assignment rules`);\n  }\n  \n  initializeSkillMapping() {\n    console.log('🎯 Initializing skill matrix and agent capabilities...');\n    \n    // Map each agent to their skills and proficiency levels\n    this.skillMatrix = new Map([\n      ['frontend-developer', {\n        primary: ['javascript', 'react', 'css', 'html', 'responsive-design'],\n        secondary: ['typescript', 'vue', 'angular', 'webpack', 'testing'],\n        proficiency: {\n          'javascript': 95,\n          'react': 90,\n          'css': 85,\n          'html': 90,\n          'typescript': 80,\n          'testing': 75\n        },\n        experience: 'senior',\n        availability: 'high',\n        workloadCapacity: 3 // Can handle 3 concurrent tasks\n      }],\n      \n      ['backend-architect', {\n        primary: ['nodejs', 'databases', 'api-design', 'microservices'],\n        secondary: ['python', 'docker', 'redis', 'security', 'performance'],\n        proficiency: {\n          'nodejs': 95,\n          'databases': 90,\n          'api-design': 95,\n          'microservices': 85,\n          'security': 80,\n          'performance': 85\n        },\n        experience: 'senior',\n        availability: 'high',\n        workloadCapacity: 3\n      }],\n      \n      ['ui-designer', {\n        primary: ['figma', 'design-systems', 'user-interface', 'prototyping'],\n        secondary: ['sketch', 'adobe-creative', 'animation', 'accessibility'],\n        proficiency: {\n          'figma': 95,\n          'design-systems': 90,\n          'user-interface': 95,\n          'prototyping': 85,\n          'accessibility': 80\n        },\n        experience: 'senior',\n        availability: 'high',\n        workloadCapacity: 2\n      }],\n      \n      ['ux-researcher', {\n        primary: ['user-research', 'data-analysis', 'personas', 'user-testing'],\n        secondary: ['surveys', 'interviews', 'a-b-testing', 'analytics'],\n        proficiency: {\n          'user-research': 95,\n          'data-analysis': 90,\n          'personas': 90,\n          'user-testing': 85,\n          'a-b-testing': 80\n        },\n        experience: 'senior',\n        availability: 'medium',\n        workloadCapacity: 2\n      }],\n      \n      ['test-writer-fixer', {\n        primary: ['test-automation', 'testing-frameworks', 'ci-cd', 'quality-assurance'],\n        secondary: ['selenium', 'jest', 'cypress', 'performance-testing'],\n        proficiency: {\n          'test-automation': 95,\n          'testing-frameworks': 90,\n          'ci-cd': 85,\n          'quality-assurance': 95,\n          'performance-testing': 80\n        },\n        experience: 'senior',\n        availability: 'high',\n        workloadCapacity: 4\n      }],\n      \n      ['devops-automator', {\n        primary: ['ci-cd', 'docker', 'cloud-platforms', 'automation'],\n        secondary: ['kubernetes', 'terraform', 'monitoring', 'security'],\n        proficiency: {\n          'ci-cd': 95,\n          'docker': 90,\n          'cloud-platforms': 90,\n          'kubernetes': 85,\n          'monitoring': 85\n        },\n        experience: 'senior',\n        availability: 'high',\n        workloadCapacity: 3\n      }],\n      \n      ['brand-guardian', {\n        primary: ['brand-design', 'visual-identity', 'guidelines', 'consistency'],\n        secondary: ['illustration', 'photography', 'video', 'social-media'],\n        proficiency: {\n          'brand-design': 95,\n          'visual-identity': 95,\n          'guidelines': 90,\n          'consistency': 95,\n          'social-media': 75\n        },\n        experience: 'senior',\n        availability: 'medium',\n        workloadCapacity: 2\n      }],\n      \n      ['growth-hacker', {\n        primary: ['growth-hacking', 'metrics-analysis', 'experimentation', 'viral-marketing'],\n        secondary: ['analytics', 'conversion-optimization', 'retention', 'acquisition'],\n        proficiency: {\n          'growth-hacking': 95,\n          'metrics-analysis': 90,\n          'experimentation': 90,\n          'viral-marketing': 85,\n          'analytics': 85\n        },\n        experience: 'senior',\n        availability: 'high',\n        workloadCapacity: 3\n      }],\n      \n      ['content-creator', {\n        primary: ['copywriting', 'content-strategy', 'brand-voice', 'storytelling'],\n        secondary: ['seo', 'social-media', 'video-editing', 'podcasting'],\n        proficiency: {\n          'copywriting': 95,\n          'content-strategy': 90,\n          'brand-voice': 90,\n          'seo': 80,\n          'social-media': 85\n        },\n        experience: 'senior',\n        availability: 'high',\n        workloadCapacity: 4\n      }],\n      \n      ['analytics-reporter', {\n        primary: ['data-analysis', 'business-intelligence', 'reporting', 'kpi-tracking'],\n        secondary: ['predictive-analytics', 'data-visualization', 'sql', 'statistics'],\n        proficiency: {\n          'data-analysis': 95,\n          'business-intelligence': 90,\n          'reporting': 95,\n          'predictive-analytics': 85,\n          'statistics': 85\n        },\n        experience: 'senior',\n        availability: 'high',\n        workloadCapacity: 3\n      }]\n    ]);\n    \n    console.log(`✅ Skill matrix configured for ${this.skillMatrix.size} agents`);\n  }\n  \n  configureWorkloadBalancing() {\n    console.log('⚖️ Configuring intelligent workload balancing...');\n    \n    // Initialize workload tracking for each agent\n    this.skillMatrix.forEach((skills, agentName) => {\n      this.workloadBalancer.set(agentName, {\n        currentLoad: 0,\n        maxCapacity: skills.workloadCapacity,\n        activeTasks: [],\n        averageTaskDuration: 0,\n        efficiency: 1.0, // Performance multiplier\n        specialization: this.calculateSpecializationScore(skills),\n        availability: skills.availability,\n        lastAssignment: null\n      });\n    });\n    \n    console.log('✅ Workload balancing configured');\n  }\n  \n  calculateSpecializationScore(skills) {\n    // Calculate how specialized an agent is (higher = more specialized)\n    const avgProficiency = Object.values(skills.proficiency).reduce((sum, val) => sum + val, 0) / Object.values(skills.proficiency).length;\n    const skillCount = skills.primary.length + skills.secondary.length;\n    \n    // More skills = less specialized, higher proficiency = more specialized\n    return (avgProficiency / 100) * (10 / skillCount);\n  }\n  \n  startPerformanceTracking() {\n    console.log('📈 Starting assignment performance tracking...');\n    \n    // Track assignment success rates every 5 minutes\n    setInterval(() => {\n      this.updatePerformanceMetrics();\n    }, 300000);\n    \n    // Adjust workload capacities based on performance every 15 minutes\n    setInterval(() => {\n      this.adjustWorkloadCapacities();\n    }, 900000);\n  }\n  \n  // INTELLIGENT AGENT ASSIGNMENT\n  async assignOptimalAgents(taskType, taskDescription, complexity = 'medium', constraints = {}) {\n    console.log(`🎯 Assigning optimal agents for task: ${taskType} (${complexity})`);\n    \n    const assignmentRule = this.assignmentRules.get(taskType);\n    if (!assignmentRule) {\n      throw new Error(`No assignment rule found for task type: ${taskType}`);\n    }\n    \n    const assignment = {\n      taskType,\n      taskDescription,\n      complexity,\n      constraints,\n      timestamp: new Date(),\n      assignedAgents: [],\n      alternativeAgents: [],\n      estimatedDuration: assignmentRule.complexity[complexity]?.timeEstimate,\n      qualityGates: assignmentRule.qualityGates,\n      dependencies: assignmentRule.dependencies,\n      handoffPlan: assignmentRule.handoffTo\n    };\n    \n    // Step 1: Identify required agents based on complexity\n    const requiredAgentCount = assignmentRule.complexity[complexity]?.agents || 1;\n    \n    // Step 2: Score and rank available agents\n    const candidateAgents = this.scoreAgentsForTask(assignmentRule, constraints);\n    \n    // Step 3: Apply workload balancing\n    const balancedCandidates = this.applyWorkloadBalancing(candidateAgents, requiredAgentCount);\n    \n    // Step 4: Select optimal combination\n    assignment.assignedAgents = this.selectOptimalCombination(\n      balancedCandidates,\n      requiredAgentCount,\n      assignmentRule\n    );\n    \n    // Step 5: Identify alternatives\n    assignment.alternativeAgents = balancedCandidates\n      .filter(agent => !assignment.assignedAgents.some(assigned => assigned.name === agent.name))\n      .slice(0, 3);\n    \n    // Step 6: Update workload tracking\n    this.updateWorkloadTracking(assignment.assignedAgents, assignment);\n    \n    // Step 7: Log assignment\n    this.logAssignment(assignment);\n    \n    console.log(`✅ Assigned ${assignment.assignedAgents.length} agents: ${assignment.assignedAgents.map(a => a.name).join(', ')}`);\n    \n    return assignment;\n  }\n  \n  scoreAgentsForTask(assignmentRule, constraints) {\n    const candidates = [];\n    \n    // Get all potential agents (primary + support)\n    const potentialAgents = [...assignmentRule.primaryAgents, ...assignmentRule.supportAgents];\n    \n    potentialAgents.forEach(agentName => {\n      const skills = this.skillMatrix.get(agentName);\n      const workload = this.workloadBalancer.get(agentName);\n      \n      if (!skills || !workload) return;\n      \n      const score = this.calculateAgentScore(agentName, skills, workload, assignmentRule, constraints);\n      \n      candidates.push({\n        name: agentName,\n        score,\n        skills,\n        workload,\n        isPrimary: assignmentRule.primaryAgents.includes(agentName),\n        reasoning: this.getScoreReasoning(score, skills, workload)\n      });\n    });\n    \n    // Sort by score (highest first)\n    return candidates.sort((a, b) => b.score - a.score);\n  }\n  \n  calculateAgentScore(agentName, skills, workload, assignmentRule, constraints) {\n    let score = 0;\n    \n    // 1. Skill match score (40% weight)\n    const skillMatch = this.calculateSkillMatch(skills, assignmentRule.requiredSkills, assignmentRule.optionalSkills);\n    score += skillMatch * 0.4;\n    \n    // 2. Availability score (25% weight)\n    const availabilityScore = this.calculateAvailabilityScore(workload);\n    score += availabilityScore * 0.25;\n    \n    // 3. Efficiency score (20% weight)\n    score += workload.efficiency * 20;\n    \n    // 4. Specialization bonus (10% weight)\n    score += workload.specialization * 10;\n    \n    // 5. Primary agent bonus (5% weight)\n    if (assignmentRule.primaryAgents.includes(agentName)) {\n      score += 5;\n    }\n    \n    // Apply constraints\n    if (constraints.preferredAgents && constraints.preferredAgents.includes(agentName)) {\n      score += 10;\n    }\n    \n    if (constraints.excludedAgents && constraints.excludedAgents.includes(agentName)) {\n      score = 0;\n    }\n    \n    if (constraints.urgency === 'high' && workload.currentLoad > workload.maxCapacity * 0.7) {\n      score *= 0.5; // Penalize overloaded agents for urgent tasks\n    }\n    \n    return Math.round(score);\n  }\n  \n  calculateSkillMatch(skills, requiredSkills, optionalSkills) {\n    let match = 0;\n    let totalWeight = 0;\n    \n    // Required skills (higher weight)\n    requiredSkills.forEach(skill => {\n      const proficiency = skills.proficiency[skill] || 0;\n      match += proficiency * 2; // Double weight for required skills\n      totalWeight += 200; // Max possible score for required skill\n    });\n    \n    // Optional skills (lower weight)\n    optionalSkills.forEach(skill => {\n      const proficiency = skills.proficiency[skill] || 0;\n      match += proficiency;\n      totalWeight += 100;\n    });\n    \n    return totalWeight > 0 ? (match / totalWeight) * 100 : 0;\n  }\n  \n  calculateAvailabilityScore(workload) {\n    const utilizationRate = workload.currentLoad / workload.maxCapacity;\n    \n    if (utilizationRate <= 0.5) return 100; // Low utilization = high availability\n    if (utilizationRate <= 0.7) return 80;\n    if (utilizationRate <= 0.9) return 60;\n    if (utilizationRate < 1.0) return 40;\n    return 20; // Overloaded\n  }\n  \n  getScoreReasoning(score, skills, workload) {\n    const reasons = [];\n    \n    if (score >= 80) reasons.push('Excellent skill match');\n    else if (score >= 60) reasons.push('Good skill match');\n    else reasons.push('Moderate skill match');\n    \n    const utilization = workload.currentLoad / workload.maxCapacity;\n    if (utilization <= 0.5) reasons.push('Low workload');\n    else if (utilization <= 0.8) reasons.push('Moderate workload');\n    else reasons.push('High workload');\n    \n    if (workload.efficiency > 1.2) reasons.push('High efficiency');\n    if (workload.specialization > 0.8) reasons.push('High specialization');\n    \n    return reasons.join(', ');\n  }\n  \n  applyWorkloadBalancing(candidates, requiredCount) {\n    // Prioritize agents with lower workload while maintaining quality\n    return candidates.filter(candidate => {\n      const utilizationRate = candidate.workload.currentLoad / candidate.workload.maxCapacity;\n      \n      // Allow some overload for high-priority tasks, but prefer balanced load\n      return utilizationRate < 1.2; // 20% overload tolerance\n    });\n  }\n  \n  selectOptimalCombination(candidates, requiredCount, assignmentRule) {\n    const selected = [];\n    const usedAgents = new Set();\n    \n    // First, select primary agents with highest scores\n    const primaryCandidates = candidates.filter(c => c.isPrimary && !usedAgents.has(c.name));\n    \n    for (const candidate of primaryCandidates) {\n      if (selected.length < requiredCount) {\n        selected.push(candidate);\n        usedAgents.add(candidate.name);\n      }\n    }\n    \n    // Then, fill remaining slots with support agents\n    const supportCandidates = candidates.filter(c => !c.isPrimary && !usedAgents.has(c.name));\n    \n    for (const candidate of supportCandidates) {\n      if (selected.length < requiredCount) {\n        selected.push(candidate);\n        usedAgents.add(candidate.name);\n      }\n    }\n    \n    return selected;\n  }\n  \n  updateWorkloadTracking(assignedAgents, assignment) {\n    assignedAgents.forEach(agent => {\n      const workload = this.workloadBalancer.get(agent.name);\n      if (workload) {\n        workload.currentLoad += 1;\n        workload.activeTasks.push({\n          taskType: assignment.taskType,\n          assignedAt: assignment.timestamp,\n          estimatedDuration: assignment.estimatedDuration\n        });\n        workload.lastAssignment = assignment.timestamp;\n      }\n    });\n  }\n  \n  logAssignment(assignment) {\n    this.assignmentHistory.push(assignment);\n    \n    // Keep only last 1000 assignments\n    if (this.assignmentHistory.length > 1000) {\n      this.assignmentHistory = this.assignmentHistory.slice(-1000);\n    }\n    \n    this.emit('agent-assigned', assignment);\n  }\n  \n  // PERFORMANCE TRACKING AND OPTIMIZATION\n  updatePerformanceMetrics() {\n    console.log('📈 Updating assignment performance metrics...');\n    \n    // Calculate success rates, efficiency metrics, etc.\n    const recentAssignments = this.assignmentHistory.slice(-50); // Last 50 assignments\n    \n    if (recentAssignments.length === 0) return;\n    \n    const metrics = {\n      totalAssignments: recentAssignments.length,\n      averageScore: 0,\n      taskTypeDistribution: {},\n      agentUtilization: {},\n      assignmentPatterns: this.analyzeAssignmentPatterns(recentAssignments)\n    };\n    \n    // Calculate average assignment score\n    const totalScore = recentAssignments.reduce((sum, assignment) => {\n      return sum + assignment.assignedAgents.reduce((agentSum, agent) => agentSum + agent.score, 0);\n    }, 0);\n    \n    const totalAgents = recentAssignments.reduce((sum, assignment) => sum + assignment.assignedAgents.length, 0);\n    metrics.averageScore = totalAgents > 0 ? Math.round(totalScore / totalAgents) : 0;\n    \n    // Task type distribution\n    recentAssignments.forEach(assignment => {\n      metrics.taskTypeDistribution[assignment.taskType] = \n        (metrics.taskTypeDistribution[assignment.taskType] || 0) + 1;\n    });\n    \n    // Agent utilization\n    this.workloadBalancer.forEach((workload, agentName) => {\n      metrics.agentUtilization[agentName] = {\n        utilization: Math.round((workload.currentLoad / workload.maxCapacity) * 100),\n        efficiency: workload.efficiency,\n        activeTasks: workload.activeTasks.length\n      };\n    });\n    \n    this.performanceMetrics.set(Date.now(), metrics);\n    \n    // Emit performance update\n    this.emit('performance-metrics-updated', metrics);\n  }\n  \n  analyzeAssignmentPatterns(assignments) {\n    const patterns = {\n      mostAssignedAgents: {},\n      popularTaskTypes: {},\n      complexityDistribution: { simple: 0, medium: 0, complex: 0 },\n      averageTeamSize: 0\n    };\n    \n    assignments.forEach(assignment => {\n      // Track agent assignments\n      assignment.assignedAgents.forEach(agent => {\n        patterns.mostAssignedAgents[agent.name] = \n          (patterns.mostAssignedAgents[agent.name] || 0) + 1;\n      });\n      \n      // Track task types\n      patterns.popularTaskTypes[assignment.taskType] = \n        (patterns.popularTaskTypes[assignment.taskType] || 0) + 1;\n      \n      // Track complexity\n      patterns.complexityDistribution[assignment.complexity]++;\n    });\n    \n    // Calculate average team size\n    patterns.averageTeamSize = assignments.length > 0 \n      ? Math.round(assignments.reduce((sum, a) => sum + a.assignedAgents.length, 0) / assignments.length)\n      : 0;\n    \n    return patterns;\n  }\n  \n  adjustWorkloadCapacities() {\n    console.log('⚖️ Adjusting workload capacities based on performance...');\n    \n    this.workloadBalancer.forEach((workload, agentName) => {\n      // Increase capacity for highly efficient agents\n      if (workload.efficiency > 1.3 && workload.currentLoad >= workload.maxCapacity) {\n        workload.maxCapacity = Math.min(workload.maxCapacity + 1, 6); // Cap at 6 tasks\n        console.log(`📈 Increased capacity for ${agentName} to ${workload.maxCapacity}`);\n      }\n      \n      // Decrease capacity for struggling agents\n      if (workload.efficiency < 0.8 && workload.maxCapacity > 1) {\n        workload.maxCapacity = Math.max(workload.maxCapacity - 1, 1); // Minimum 1 task\n        console.log(`📉 Decreased capacity for ${agentName} to ${workload.maxCapacity}`);\n      }\n    });\n  }\n  \n  // TASK COMPLETION TRACKING\n  markTaskCompleted(agentName, taskType, success = true, duration = null) {\n    const workload = this.workloadBalancer.get(agentName);\n    if (!workload) return;\n    \n    // Update workload\n    workload.currentLoad = Math.max(0, workload.currentLoad - 1);\n    \n    // Remove completed task\n    workload.activeTasks = workload.activeTasks.filter(task => \n      task.taskType !== taskType\n    );\n    \n    // Update efficiency based on success and duration\n    if (success) {\n      workload.efficiency = Math.min(2.0, workload.efficiency * 1.05); // Gradual improvement\n    } else {\n      workload.efficiency = Math.max(0.5, workload.efficiency * 0.95); // Gradual decline\n    }\n    \n    // Update average task duration if provided\n    if (duration) {\n      if (workload.averageTaskDuration === 0) {\n        workload.averageTaskDuration = duration;\n      } else {\n        workload.averageTaskDuration = (workload.averageTaskDuration + duration) / 2;\n      }\n    }\n    \n    console.log(`✅ Task completed: ${agentName} - ${taskType} (${success ? 'success' : 'failed'})`);\n    \n    this.emit('task-completed', {\n      agentName,\n      taskType,\n      success,\n      duration,\n      newEfficiency: workload.efficiency\n    });\n  }\n  \n  // PUBLIC API METHODS\n  getAssignmentRecommendation(taskType, complexity = 'medium', constraints = {}) {\n    try {\n      return this.assignOptimalAgents(taskType, 'Task analysis', complexity, constraints);\n    } catch (error) {\n      console.error('Assignment recommendation error:', error);\n      return null;\n    }\n  }\n  \n  getAgentWorkload(agentName) {\n    return this.workloadBalancer.get(agentName) || null;\n  }\n  \n  getAllWorkloads() {\n    return Object.fromEntries(this.workloadBalancer);\n  }\n  \n  getAssignmentHistory(limit = 20) {\n    return this.assignmentHistory.slice(-limit);\n  }\n  \n  getPerformanceMetrics() {\n    const entries = Array.from(this.performanceMetrics.entries());\n    return entries.length > 0 ? entries[entries.length - 1][1] : null;\n  }\n  \n  getAvailableTaskTypes() {\n    return Array.from(this.assignmentRules.keys());\n  }\n  \n  getTaskTypeDetails(taskType) {\n    return this.assignmentRules.get(taskType) || null;\n  }\n  \n  // UTILITY METHODS\n  getSystemLoad() {\n    let totalLoad = 0;\n    let totalCapacity = 0;\n    \n    this.workloadBalancer.forEach(workload => {\n      totalLoad += workload.currentLoad;\n      totalCapacity += workload.maxCapacity;\n    });\n    \n    return {\n      utilization: totalCapacity > 0 ? Math.round((totalLoad / totalCapacity) * 100) : 0,\n      totalLoad,\n      totalCapacity,\n      availableCapacity: totalCapacity - totalLoad\n    };\n  }\n  \n  getAgentRecommendationsForSkills(requiredSkills) {\n    const recommendations = [];\n    \n    this.skillMatrix.forEach((skills, agentName) => {\n      const matchScore = this.calculateSkillMatch(skills, requiredSkills, []);\n      const workload = this.workloadBalancer.get(agentName);\n      \n      if (matchScore > 50) { // Only recommend agents with 50%+ skill match\n        recommendations.push({\n          agentName,\n          skillMatch: Math.round(matchScore),\n          availability: this.calculateAvailabilityScore(workload),\n          skills: skills.primary.filter(skill => requiredSkills.includes(skill))\n        });\n      }\n    });\n    \n    return recommendations.sort((a, b) => b.skillMatch - a.skillMatch);\n  }\n}\n\nmodule.exports = {\n  AgentAssignmentMatrix\n};"}, {"old_string": "      // DEVELOPMENT TASKS\\n      ['frontend-development', {\\n        primaryAgents: ['frontend-developer'],\\n        supportAgents: ['ui-designer', 'whimsy-injector'],\\n        requiredSkills: ['javascript', 'react', 'css', 'html'],\\n        optionalSkills: ['typescript', 'webpack', 'testing'],\\n        complexity: {\\n          simple: { agents: 1, timeEstimate: '2-4 hours' },\\n          medium: { agents: 2, timeEstimate: '1-2 days' },\\n          complex: { agents: 3, timeEstimate: '3-5 days' }\\n        },\\n        dependencies: ['ui-designer'],\\n        handoffTo: ['test-writer-fixer'],\\n        qualityGates: ['code-review', 'testing', 'accessibility-check']\\n      }],", "new_string": "      // DEVELOPMENT TASKS\n      ['frontend-development', {\n        primaryAgents: ['frontend-developer'],\n        supportAgents: ['ui-designer', 'whimsy-injector'],\n        requiredSkills: ['javascript', 'react', 'css', 'html'],\n        optionalSkills: ['typescript', 'webpack', 'testing'],\n        complexity: {\n          simple: { agents: 1, timeEstimate: '2-4 hours' },\n          medium: { agents: 2, timeEstimate: '1-2 days' },\n          complex: { agents: 3, timeEstimate: '3-5 days' }\n        },\n        dependencies: ['ui-designer'],\n        handoffTo: ['test-writer-fixer'],\n        qualityGates: ['code-review', 'testing', 'accessibility-check']\n      }],"}]