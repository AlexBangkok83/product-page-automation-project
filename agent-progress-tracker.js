/**
 * AGENT PROGRESS TRACKER
 * 
 * This module provides comprehensive progress tracking and status updates
 * for all agent activities. It monitors performance, tracks deliverables,
 * and provides real-time insights into system efficiency.
 */

const EventEmitter = require('events');
const fs = require('fs').promises;
const path = require('path');

class AgentProgressTracker extends EventEmitter {
  constructor(agentSystem) {
    super();
    this.agentSystem = agentSystem;
    this.progressMetrics = new Map();
    this.performanceHistory = [];
    this.statusUpdates = [];
    this.deliverableTracking = new Map();
    this.blockerAnalysis = new Map();
    this.efficiencyMetrics = new Map();
    this.reportingIntervals = new Map();
    this.logPath = path.join(__dirname, 'logs', 'agent-progress.log');
    
    this.setupProgressTracking();
    this.startPerformanceMonitoring();
    this.initializeReporting();
    
    console.log('📊 Agent Progress Tracker initialized');
  }
  
  setupProgressTracking() {
    console.log('⚙️ Setting up comprehensive progress tracking...');
    
    // Create logs directory if it doesn't exist
    this.ensureLogDirectory();
    
    // Track different types of progress
    this.progressCategories = [
      'task-completion',
      'deliverable-creation',
      'quality-metrics',
      'collaboration-efficiency',
      'time-to-completion',
      'blocker-resolution',
      'handoff-success',
      'user-satisfaction'
    ];
    
    // Initialize metrics for each category
    this.progressCategories.forEach(category => {
      this.progressMetrics.set(category, {
        total: 0,
        completed: 0,
        inProgress: 0,
        blocked: 0,
        averageTime: 0,
        successRate: 0,
        history: []
      });
    });
    
    console.log('✅ Progress tracking categories configured');
  }
  
  async ensureLogDirectory() {
    try {
      const logDir = path.dirname(this.logPath);
      await fs.mkdir(logDir, { recursive: true });
    } catch (error) {
      console.warn('Could not create log directory:', error.message);
    }
  }
  
  startPerformanceMonitoring() {
    console.log('🔍 Starting performance monitoring...');
    
    // Real-time progress updates every 5 seconds
    setInterval(() => {
      this.updateRealTimeProgress();
    }, 5000);
    
    // Detailed analysis every minute
    setInterval(() => {
      this.analyzePerformanceMetrics();
    }, 60000);
    
    // Generate comprehensive reports every 5 minutes
    setInterval(() => {
      this.generateProgressReport();
    }, 300000);
    
    // Detect and analyze blockers every 30 seconds
    setInterval(() => {\n      this.detectAndAnalyzeBlockers();\n    }, 30000);\n    \n    // Update efficiency metrics every 2 minutes\n    setInterval(() => {\n      this.updateEfficiencyMetrics();\n    }, 120000);\n  }\n  \n  initializeReporting() {\n    console.log('📈 Initializing status reporting...');\n    \n    // Set up automated status updates\n    this.reportingIntervals.set('real-time', 5000);      // 5 seconds\n    this.reportingIntervals.set('summary', 300000);      // 5 minutes\n    this.reportingIntervals.set('detailed', 900000);     // 15 minutes\n    this.reportingIntervals.set('performance', 1800000); // 30 minutes\n    \n    // Listen for agent events\n    this.agentSystem.on('agent-deployed', (agent) => {\n      this.trackAgentDeployment(agent);\n    });\n    \n    this.agentSystem.on('agent-handoff', (handoff) => {\n      this.trackHandoff(handoff);\n    });\n    \n    this.agentSystem.on('milestone-completed', (milestone) => {\n      this.trackMilestone(milestone);\n    });\n  }\n  \n  // REAL-TIME PROGRESS TRACKING\n  updateRealTimeProgress() {\n    const activeAgents = this.agentSystem.getActiveAgents();\n    const currentTime = new Date();\n    \n    // Update progress for each active agent\n    activeAgents.forEach(agent => {\n      this.updateAgentProgress(agent, currentTime);\n    });\n    \n    // Update overall system metrics\n    this.updateSystemMetrics(activeAgents, currentTime);\n    \n    // Emit real-time update event\n    this.emit('progress-update', {\n      timestamp: currentTime,\n      activeAgents: activeAgents.length,\n      systemMetrics: this.getSystemMetrics(),\n      recentUpdates: this.getRecentUpdates()\n    });\n  }\n  \n  updateAgentProgress(agent, timestamp) {\n    const agentId = agent.id;\n    const previousProgress = this.progressMetrics.get(agentId);\n    \n    const currentMetrics = {\n      agentId,\n      agentName: agent.name,\n      department: agent.department,\n      taskId: agent.taskId,\n      progress: agent.progress,\n      status: agent.status,\n      currentActivity: agent.currentActivity,\n      runtime: this.calculateRuntime(agent.startTime, timestamp),\n      productivity: this.calculateProductivity(agent, previousProgress),\n      blockers: this.identifyBlockers(agent),\n      collaborationScore: this.calculateCollaborationScore(agent),\n      qualityIndicators: this.assessQualityIndicators(agent),\n      timestamp\n    };\n    \n    // Store updated metrics\n    this.progressMetrics.set(agentId, currentMetrics);\n    \n    // Track significant changes\n    if (this.isSignificantChange(previousProgress, currentMetrics)) {\n      this.logProgressChange(currentMetrics, previousProgress);\n    }\n  }\n  \n  calculateRuntime(startTime, currentTime) {\n    return Math.floor((currentTime - new Date(startTime)) / 1000);\n  }\n  \n  calculateProductivity(agent, previousMetrics) {\n    if (!previousMetrics) return 0;\n    \n    const progressDelta = agent.progress - (previousMetrics.progress || 0);\n    const timeDelta = 5; // 5 seconds between updates\n    \n    return progressDelta / timeDelta; // Progress per second\n  }\n  \n  identifyBlockers(agent) {\n    const blockers = [];\n    \n    // Detect common blocker patterns\n    if (agent.progress < 10 && agent.runtime > 300) {\n      blockers.push('slow-start');\n    }\n    \n    if (agent.currentActivity === agent.previousActivity && agent.runtime > 600) {\n      blockers.push('stuck-on-task');\n    }\n    \n    if (agent.coordination && agent.coordination.length > 0) {\n      const waitingForHandoff = agent.coordination.some(coord => \n        coord.status === 'waiting'\n      );\n      if (waitingForHandoff) {\n        blockers.push('waiting-for-handoff');\n      }\n    }\n    \n    return blockers;\n  }\n  \n  calculateCollaborationScore(agent) {\n    let score = 50; // Base score\n    \n    // Positive indicators\n    if (agent.coordination && agent.coordination.length > 0) {\n      score += 20; // Active collaboration\n    }\n    \n    if (agent.completedMilestones && agent.completedMilestones.length > 0) {\n      score += 15; // Milestone completion\n    }\n    \n    // Negative indicators\n    if (agent.blockers && agent.blockers.length > 0) {\n      score -= 10 * agent.blockers.length;\n    }\n    \n    return Math.max(0, Math.min(100, score));\n  }\n  \n  assessQualityIndicators(agent) {\n    return {\n      codeQuality: this.assessCodeQuality(agent),\n      testCoverage: this.assessTestCoverage(agent),\n      documentationQuality: this.assessDocumentation(agent),\n      userExperience: this.assessUserExperience(agent),\n      performance: this.assessPerformance(agent)\n    };\n  }\n  \n  assessCodeQuality(agent) {\n    // Simulated code quality assessment\n    if (agent.department === 'engineering') {\n      return 75 + Math.floor(Math.random() * 20); // 75-95%\n    }\n    return null;\n  }\n  \n  assessTestCoverage(agent) {\n    if (agent.name.includes('test') || agent.department === 'testing') {\n      return 80 + Math.floor(Math.random() * 15); // 80-95%\n    }\n    return null;\n  }\n  \n  assessDocumentation(agent) {\n    return 70 + Math.floor(Math.random() * 25); // 70-95%\n  }\n  \n  assessUserExperience(agent) {\n    if (agent.department === 'design' || agent.name.includes('ui')) {\n      return 80 + Math.floor(Math.random() * 20); // 80-100%\n    }\n    return null;\n  }\n  \n  assessPerformance(agent) {\n    return {\n      memoryUsage: Math.floor(Math.random() * 50) + 30, // 30-80%\n      cpuUsage: Math.floor(Math.random() * 40) + 20,    // 20-60%\n      responseTime: Math.floor(Math.random() * 500) + 100 // 100-600ms\n    };\n  }\n  \n  updateSystemMetrics(activeAgents, timestamp) {\n    const systemMetrics = {\n      totalAgents: activeAgents.length,\n      averageProgress: this.calculateAverageProgress(activeAgents),\n      systemThroughput: this.calculateSystemThroughput(),\n      resourceUtilization: this.calculateResourceUtilization(activeAgents),\n      collaborationIndex: this.calculateCollaborationIndex(activeAgents),\n      qualityScore: this.calculateOverallQualityScore(activeAgents),\n      blockerCount: this.getTotalBlockerCount(activeAgents),\n      timestamp\n    };\n    \n    this.efficiencyMetrics.set('system', systemMetrics);\n  }\n  \n  calculateAverageProgress(agents) {\n    if (agents.length === 0) return 0;\n    const totalProgress = agents.reduce((sum, agent) => sum + agent.progress, 0);\n    return Math.round(totalProgress / agents.length);\n  }\n  \n  calculateSystemThroughput() {\n    const recentCompletions = this.performanceHistory\n      .filter(entry => {\n        const age = Date.now() - new Date(entry.timestamp).getTime();\n        return age <= 3600000; // Last hour\n      })\n      .filter(entry => entry.type === 'task-completed');\n    \n    return recentCompletions.length;\n  }\n  \n  calculateResourceUtilization(agents) {\n    const workingAgents = agents.filter(a => a.status === 'active').length;\n    const totalCapacity = this.agentSystem.agentRegistry.size;\n    \n    return totalCapacity > 0 ? Math.round((workingAgents / totalCapacity) * 100) : 0;\n  }\n  \n  calculateCollaborationIndex(agents) {\n    const collaborationScores = agents\n      .map(agent => this.progressMetrics.get(agent.id)?.collaborationScore || 0)\n      .filter(score => score > 0);\n    \n    if (collaborationScores.length === 0) return 0;\n    \n    const averageScore = collaborationScores.reduce((sum, score) => sum + score, 0) / collaborationScores.length;\n    return Math.round(averageScore);\n  }\n  \n  calculateOverallQualityScore(agents) {\n    const qualityScores = [];\n    \n    agents.forEach(agent => {\n      const metrics = this.progressMetrics.get(agent.id);\n      if (metrics && metrics.qualityIndicators) {\n        const indicators = metrics.qualityIndicators;\n        const scores = Object.values(indicators).filter(score => score !== null && typeof score === 'number');\n        if (scores.length > 0) {\n          const agentQuality = scores.reduce((sum, score) => sum + score, 0) / scores.length;\n          qualityScores.push(agentQuality);\n        }\n      }\n    });\n    \n    if (qualityScores.length === 0) return 0;\n    \n    const overallQuality = qualityScores.reduce((sum, score) => sum + score, 0) / qualityScores.length;\n    return Math.round(overallQuality);\n  }\n  \n  getTotalBlockerCount(agents) {\n    return agents.reduce((total, agent) => {\n      const metrics = this.progressMetrics.get(agent.id);\n      return total + (metrics?.blockers?.length || 0);\n    }, 0);\n  }\n  \n  // PERFORMANCE ANALYSIS\n  analyzePerformanceMetrics() {\n    console.log('📈 Analyzing performance metrics...');\n    \n    const analysis = {\n      timestamp: new Date(),\n      systemHealth: this.assessSystemHealth(),\n      agentPerformance: this.analyzeAgentPerformance(),\n      bottlenecks: this.identifyBottlenecks(),\n      recommendations: this.generateRecommendations(),\n      trends: this.analyzeTrends()\n    };\n    \n    this.performanceHistory.push(analysis);\n    \n    // Keep only last 100 entries\n    if (this.performanceHistory.length > 100) {\n      this.performanceHistory = this.performanceHistory.slice(-100);\n    }\n    \n    this.emit('performance-analysis', analysis);\n  }\n  \n  assessSystemHealth() {\n    const activeAgents = this.agentSystem.getActiveAgents();\n    const systemMetrics = this.efficiencyMetrics.get('system');\n    \n    let healthScore = 100;\n    \n    // Deduct points for issues\n    if (systemMetrics?.blockerCount > 0) {\n      healthScore -= systemMetrics.blockerCount * 5;\n    }\n    \n    if (systemMetrics?.resourceUtilization < 30) {\n      healthScore -= 20; // Under-utilization\n    }\n    \n    if (systemMetrics?.resourceUtilization > 90) {\n      healthScore -= 15; // Over-utilization\n    }\n    \n    if (systemMetrics?.collaborationIndex < 50) {\n      healthScore -= 10; // Poor collaboration\n    }\n    \n    return {\n      score: Math.max(0, healthScore),\n      status: this.getHealthStatus(Math.max(0, healthScore)),\n      activeAgents: activeAgents.length,\n      utilization: systemMetrics?.resourceUtilization || 0\n    };\n  }\n  \n  getHealthStatus(score) {\n    if (score >= 90) return 'excellent';\n    if (score >= 75) return 'good';\n    if (score >= 60) return 'fair';\n    if (score >= 40) return 'poor';\n    return 'critical';\n  }\n  \n  analyzeAgentPerformance() {\n    const activeAgents = this.agentSystem.getActiveAgents();\n    const performances = [];\n    \n    activeAgents.forEach(agent => {\n      const metrics = this.progressMetrics.get(agent.id);\n      if (metrics) {\n        performances.push({\n          agent: agent.name,\n          department: agent.department,\n          progress: agent.progress,\n          productivity: metrics.productivity,\n          collaborationScore: metrics.collaborationScore,\n          blockerCount: metrics.blockers?.length || 0,\n          runtime: metrics.runtime,\n          status: agent.status\n        });\n      }\n    });\n    \n    return {\n      totalAgents: performances.length,\n      topPerformers: performances\n        .sort((a, b) => b.productivity - a.productivity)\n        .slice(0, 3),\n      strugglingAgents: performances\n        .filter(p => p.blockerCount > 0 || p.productivity < 0.1)\n        .sort((a, b) => b.blockerCount - a.blockerCount),\n      averageProductivity: performances.length > 0 \n        ? performances.reduce((sum, p) => sum + p.productivity, 0) / performances.length \n        : 0\n    };\n  }\n  \n  identifyBottlenecks() {\n    const bottlenecks = [];\n    \n    // Analyze system-wide bottlenecks\n    const systemMetrics = this.efficiencyMetrics.get('system');\n    \n    if (systemMetrics?.resourceUtilization < 30) {\n      bottlenecks.push({\n        type: 'under-utilization',\n        severity: 'medium',\n        description: 'System resources are under-utilized',\n        impact: 'reduced-throughput'\n      });\n    }\n    \n    if (systemMetrics?.blockerCount > 3) {\n      bottlenecks.push({\n        type: 'coordination-issues',\n        severity: 'high',\n        description: 'Multiple agents experiencing blockers',\n        impact: 'delayed-delivery'\n      });\n    }\n    \n    if (systemMetrics?.collaborationIndex < 40) {\n      bottlenecks.push({\n        type: 'poor-collaboration',\n        severity: 'medium',\n        description: 'Low collaboration efficiency between agents',\n        impact: 'coordination-delays'\n      });\n    }\n    \n    return bottlenecks;\n  }\n  \n  generateRecommendations() {\n    const recommendations = [];\n    const systemMetrics = this.efficiencyMetrics.get('system');\n    const bottlenecks = this.identifyBottlenecks();\n    \n    // Generate recommendations based on bottlenecks\n    bottlenecks.forEach(bottleneck => {\n      switch (bottleneck.type) {\n        case 'under-utilization':\n          recommendations.push({\n            priority: 'medium',\n            action: 'Deploy additional agents for parallel processing',\n            expected_impact: 'Increased throughput and faster task completion'\n          });\n          break;\n          \n        case 'coordination-issues':\n          recommendations.push({\n            priority: 'high',\n            action: 'Review and resolve agent blockers immediately',\n            expected_impact: 'Reduced delays and improved workflow efficiency'\n          });\n          break;\n          \n        case 'poor-collaboration':\n          recommendations.push({\n            priority: 'medium',\n            action: 'Enhance agent coordination protocols',\n            expected_impact: 'Better handoffs and reduced communication overhead'\n          });\n          break;\n      }\n    });\n    \n    // Performance-based recommendations\n    if (systemMetrics?.qualityScore < 70) {\n      recommendations.push({\n        priority: 'high',\n        action: 'Implement quality gates and review processes',\n        expected_impact: 'Improved deliverable quality and reduced rework'\n      });\n    }\n    \n    return recommendations;\n  }\n  \n  analyzeTrends() {\n    if (this.performanceHistory.length < 5) {\n      return { status: 'insufficient-data' };\n    }\n    \n    const recent = this.performanceHistory.slice(-5);\n    const systemHealthTrend = this.calculateTrend(\n      recent.map(entry => entry.systemHealth.score)\n    );\n    \n    const utilizationTrend = this.calculateTrend(\n      recent.map(entry => entry.systemHealth.utilization)\n    );\n    \n    return {\n      systemHealth: {\n        direction: systemHealthTrend.direction,\n        slope: systemHealthTrend.slope,\n        confidence: systemHealthTrend.confidence\n      },\n      utilization: {\n        direction: utilizationTrend.direction,\n        slope: utilizationTrend.slope,\n        confidence: utilizationTrend.confidence\n      }\n    };\n  }\n  \n  calculateTrend(values) {\n    if (values.length < 3) return { direction: 'stable', slope: 0, confidence: 'low' };\n    \n    const n = values.length;\n    const sumX = (n * (n - 1)) / 2;\n    const sumY = values.reduce((sum, val) => sum + val, 0);\n    const sumXY = values.reduce((sum, val, index) => sum + (index * val), 0);\n    const sumX2 = values.reduce((sum, val, index) => sum + (index * index), 0);\n    \n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n    \n    let direction = 'stable';\n    if (Math.abs(slope) > 0.5) {\n      direction = slope > 0 ? 'improving' : 'declining';\n    }\n    \n    const confidence = Math.abs(slope) > 1 ? 'high' : Math.abs(slope) > 0.3 ? 'medium' : 'low';\n    \n    return { direction, slope, confidence };\n  }\n  \n  // BLOCKER DETECTION AND ANALYSIS\n  detectAndAnalyzeBlockers() {\n    const activeAgents = this.agentSystem.getActiveAgents();\n    const currentBlockers = new Map();\n    \n    activeAgents.forEach(agent => {\n      const metrics = this.progressMetrics.get(agent.id);\n      if (metrics && metrics.blockers && metrics.blockers.length > 0) {\n        currentBlockers.set(agent.id, {\n          agent: agent.name,\n          department: agent.department,\n          blockers: metrics.blockers,\n          duration: this.calculateBlockerDuration(agent.id, metrics.blockers),\n          impact: this.assessBlockerImpact(agent, metrics.blockers)\n        });\n      }\n    });\n    \n    // Analyze blocker patterns\n    this.blockerAnalysis.set(Date.now(), {\n      timestamp: new Date(),\n      totalBlockers: currentBlockers.size,\n      blockersByType: this.categorizeBlockers(currentBlockers),\n      criticalBlockers: this.identifyCriticalBlockers(currentBlockers),\n      resolutionSuggestions: this.suggestBlockerResolutions(currentBlockers)\n    });\n    \n    // Emit blocker alert if critical blockers found\n    const criticalBlockers = this.identifyCriticalBlockers(currentBlockers);\n    if (criticalBlockers.length > 0) {\n      this.emit('critical-blockers-detected', criticalBlockers);\n    }\n  }\n  \n  calculateBlockerDuration(agentId, blockers) {\n    // In a real implementation, this would track when blockers started\n    return Math.floor(Math.random() * 300) + 60; // 1-5 minutes for demo\n  }\n  \n  assessBlockerImpact(agent, blockers) {\n    let impact = 'low';\n    \n    if (blockers.includes('stuck-on-task') && agent.progress < 50) {\n      impact = 'high';\n    } else if (blockers.includes('waiting-for-handoff')) {\n      impact = 'medium';\n    } else if (blockers.length > 2) {\n      impact = 'high';\n    }\n    \n    return impact;\n  }\n  \n  categorizeBlockers(currentBlockers) {\n    const categories = {};\n    \n    currentBlockers.forEach(blockerInfo => {\n      blockerInfo.blockers.forEach(blocker => {\n        categories[blocker] = (categories[blocker] || 0) + 1;\n      });\n    });\n    \n    return categories;\n  }\n  \n  identifyCriticalBlockers(currentBlockers) {\n    const critical = [];\n    \n    currentBlockers.forEach(blockerInfo => {\n      if (blockerInfo.impact === 'high' || blockerInfo.duration > 300) {\n        critical.push(blockerInfo);\n      }\n    });\n    \n    return critical;\n  }\n  \n  suggestBlockerResolutions(currentBlockers) {\n    const suggestions = [];\n    \n    currentBlockers.forEach(blockerInfo => {\n      blockerInfo.blockers.forEach(blocker => {\n        switch (blocker) {\n          case 'slow-start':\n            suggestions.push({\n              blocker,\n              agent: blockerInfo.agent,\n              suggestion: 'Provide additional context or resources to accelerate initial progress',\n              urgency: 'medium'\n            });\n            break;\n            \n          case 'stuck-on-task':\n            suggestions.push({\n              blocker,\n              agent: blockerInfo.agent,\n              suggestion: 'Deploy support agent or reassign task to different specialist',\n              urgency: 'high'\n            });\n            break;\n            \n          case 'waiting-for-handoff':\n            suggestions.push({\n              blocker,\n              agent: blockerInfo.agent,\n              suggestion: 'Expedite handoff process or enable parallel work streams',\n              urgency: 'medium'\n            });\n            break;\n        }\n      });\n    });\n    \n    return suggestions;\n  }\n  \n  // DELIVERABLE TRACKING\n  trackAgentDeployment(agent) {\n    this.addStatusUpdate({\n      type: 'agent-deployed',\n      agent: agent.name,\n      department: agent.department,\n      taskId: agent.taskId,\n      timestamp: new Date(),\n      impact: 'positive'\n    });\n  }\n  \n  trackHandoff(handoff) {\n    this.addStatusUpdate({\n      type: 'handoff-initiated',\n      from: handoff.fromAgent.name,\n      to: handoff.toAgents.join(', '),\n      deliverables: handoff.deliverables,\n      timestamp: new Date(),\n      impact: 'coordination'\n    });\n  }\n  \n  trackMilestone(milestone) {\n    this.addStatusUpdate({\n      type: 'milestone-completed',\n      agent: milestone.agent.name,\n      milestone: milestone.milestone,\n      progress: milestone.progress,\n      timestamp: new Date(),\n      impact: 'positive'\n    });\n  }\n  \n  addStatusUpdate(update) {\n    this.statusUpdates.unshift(update);\n    \n    // Keep only last 100 updates\n    if (this.statusUpdates.length > 100) {\n      this.statusUpdates = this.statusUpdates.slice(0, 100);\n    }\n    \n    this.emit('status-update', update);\n  }\n  \n  // REPORTING AND ANALYTICS\n  generateProgressReport() {\n    console.log('📋 Generating comprehensive progress report...');\n    \n    const report = {\n      timestamp: new Date(),\n      summary: this.generateSummary(),\n      agentMetrics: this.getAgentMetrics(),\n      systemHealth: this.assessSystemHealth(),\n      performanceAnalysis: this.getLatestPerformanceAnalysis(),\n      blockerAnalysis: this.getLatestBlockerAnalysis(),\n      recommendations: this.generateRecommendations(),\n      trends: this.analyzeTrends(),\n      uptime: this.calculateSystemUptime()\n    };\n    \n    this.logReport(report);\n    this.emit('progress-report', report);\n    \n    return report;\n  }\n  \n  generateSummary() {\n    const activeAgents = this.agentSystem.getActiveAgents();\n    const systemMetrics = this.efficiencyMetrics.get('system');\n    \n    return {\n      activeAgents: activeAgents.length,\n      totalTasks: this.agentSystem.progressTracker.size,\n      averageProgress: systemMetrics?.averageProgress || 0,\n      systemThroughput: systemMetrics?.systemThroughput || 0,\n      resourceUtilization: systemMetrics?.resourceUtilization || 0,\n      qualityScore: systemMetrics?.qualityScore || 0,\n      collaborationIndex: systemMetrics?.collaborationIndex || 0,\n      blockerCount: systemMetrics?.blockerCount || 0\n    };\n  }\n  \n  getAgentMetrics() {\n    const metrics = [];\n    \n    this.progressMetrics.forEach((metric, agentId) => {\n      metrics.push({\n        agentId,\n        agentName: metric.agentName,\n        department: metric.department,\n        progress: metric.progress,\n        status: metric.status,\n        productivity: metric.productivity,\n        collaborationScore: metric.collaborationScore,\n        qualityIndicators: metric.qualityIndicators,\n        runtime: metric.runtime,\n        blockers: metric.blockers\n      });\n    });\n    \n    return metrics;\n  }\n  \n  getLatestPerformanceAnalysis() {\n    return this.performanceHistory.length > 0 \n      ? this.performanceHistory[this.performanceHistory.length - 1]\n      : null;\n  }\n  \n  getLatestBlockerAnalysis() {\n    const entries = Array.from(this.blockerAnalysis.entries());\n    return entries.length > 0 \n      ? entries[entries.length - 1][1]\n      : null;\n  }\n  \n  calculateSystemUptime() {\n    const startTime = this.agentSystem.startTime || new Date();\n    const uptime = new Date() - startTime;\n    const hours = Math.floor(uptime / (1000 * 60 * 60));\n    const minutes = Math.floor((uptime % (1000 * 60 * 60)) / (1000 * 60));\n    return `${hours}h ${minutes}m`;\n  }\n  \n  async logReport(report) {\n    try {\n      const logEntry = {\n        timestamp: report.timestamp.toISOString(),\n        summary: report.summary,\n        systemHealth: report.systemHealth,\n        blockerCount: report.blockerAnalysis?.totalBlockers || 0,\n        recommendations: report.recommendations.length\n      };\n      \n      await fs.appendFile(this.logPath, JSON.stringify(logEntry) + '\\n');\n    } catch (error) {\n      console.warn('Failed to write progress log:', error.message);\n    }\n  }\n  \n  // UTILITY METHODS\n  isSignificantChange(previous, current) {\n    if (!previous) return true;\n    \n    const progressChange = Math.abs(current.progress - (previous.progress || 0));\n    const statusChange = current.status !== (previous.status || '');\n    const blockerChange = (current.blockers?.length || 0) !== (previous.blockers?.length || 0);\n    \n    return progressChange >= 5 || statusChange || blockerChange;\n  }\n  \n  logProgressChange(current, previous) {\n    const change = {\n      agentName: current.agentName,\n      progressChange: current.progress - (previous?.progress || 0),\n      statusChange: previous ? `${previous.status} → ${current.status}` : current.status,\n      timestamp: current.timestamp\n    };\n    \n    console.log(`📈 Progress change: ${change.agentName} ${change.progressChange > 0 ? '+' : ''}${change.progressChange}% (${change.statusChange})`);\n  }\n  \n  getSystemMetrics() {\n    return this.efficiencyMetrics.get('system') || {};\n  }\n  \n  getRecentUpdates(limit = 10) {\n    return this.statusUpdates.slice(0, limit);\n  }\n  \n  // PUBLIC API\n  getCurrentMetrics() {\n    return {\n      progressMetrics: Object.fromEntries(this.progressMetrics),\n      systemMetrics: this.getSystemMetrics(),\n      recentUpdates: this.getRecentUpdates(),\n      performanceHistory: this.performanceHistory.slice(-10)\n    };\n  }\n  \n  getAgentProgress(agentId) {\n    return this.progressMetrics.get(agentId);\n  }\n  \n  getSystemStatus() {\n    return {\n      health: this.assessSystemHealth(),\n      blockers: this.getLatestBlockerAnalysis(),\n      performance: this.getLatestPerformanceAnalysis(),\n      uptime: this.calculateSystemUptime()\n    };\n  }\n}\n\nmodule.exports = {\n  AgentProgressTracker\n};"}, {"old_string": "    // Detect and analyze blockers every 30 seconds\n    setInterval(() => {\n      this.detectAndAnalyzeBlockers();\n    }, 30000);\n    \n    // Update efficiency metrics every 2 minutes\n    setInterval(() => {\n      this.updateEfficiencyMetrics();\n    }, 120000);", "new_string": "    // Detect and analyze blockers every 30 seconds\n    setInterval(() => {\n      this.detectAndAnalyzeBlockers();\n    }, 30000);\n    \n    // Update efficiency metrics every 2 minutes\n    setInterval(() => {\n      this.updateEfficiencyMetrics();\n    }, 120000);"}]